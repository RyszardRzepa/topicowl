import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { db } from '@/server/db';
import { articles } from '@/server/db/schema';
import { eq } from 'drizzle-orm';
import type { ApiResponse } from '@/types/types';
import { updateProgress } from '@/lib/progress-tracker';

// Types colocated with this API route
export interface ArticleGenerationRequest {
  articleId: string;
  forceRegenerate?: boolean;
}

// Main generation function - simplified version
async function generateArticleContent(articleId: string) {
  try {
    updateProgress(articleId, 'researching', 10, 'Starting research phase');

    // Get article from database
    const [article] = await db
      .select()
      .from(articles)
      .where(eq(articles.id, parseInt(articleId)));

    if (!article) {
      throw new Error('Article not found');
    }

    // Update status to generating
    await db
      .update(articles)
      .set({ status: 'generating', updatedAt: new Date() })
      .where(eq(articles.id, parseInt(articleId)));

    updateProgress(articleId, 'writing', 40, 'Generating content');

    // For now, we'll just mark as completed with a placeholder
    // In a real implementation, you would integrate with the AI services here
    const placeholderContent = `# ${article.title}

This article content will be generated by the AI system.

Keywords: ${Array.isArray(article.keywords) ? (article.keywords as string[]).join(', ') : 'None'}`;

    // Save generated content
    await db
      .update(articles)
      .set({
        draft: placeholderContent,
        status: 'to_generate', // Ready for review
        updatedAt: new Date(),
      })
      .where(eq(articles.id, parseInt(articleId)));

    updateProgress(articleId, 'completed', 100, 'Generation completed');

  } catch (error) {
    console.error('Generation error:', error);
    updateProgress(articleId, 'failed', 0, undefined);
    
    // Update article status to failed
    await db
      .update(articles)
      .set({
        status: 'idea', // Reset to idea status
        updatedAt: new Date(),
      })
      .where(eq(articles.id, parseInt(articleId)));
  }
}

export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    
    if (!id || isNaN(parseInt(id))) {
      return NextResponse.json(
        { success: false, error: "Invalid article ID" } as ApiResponse,
        { status: 400 }
      );
    }

    // Initialize progress tracking
    updateProgress(id, 'pending', 0, 'Initializing generation');

    // Start generation process (runs in background)
    generateArticleContent(id).catch(error => {
      console.error('Background generation failed:', error);
    });

    return NextResponse.json({ 
      success: true,
      data: {
        message: "Article generation started",
        articleId: id,
      },
    } as ApiResponse);

  } catch (error) {
    console.error('Generate article error:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to start article generation' 
      } as ApiResponse,
      { status: 500 }
    );
  }
}